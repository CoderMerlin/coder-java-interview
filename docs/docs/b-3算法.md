### 1.1　排序
### 算法笔试模拟题精解之“数组变换”

**简介**： 本题要分情况讨论，根据不同的情况变换不同的解决方式。

#### 题目描述

源码地址：https://github.com/liuyubobobo/Play-with-Algorithm-Interview



等级：中等
知识点：排序、贪心


给出一个长度为 n 的数组，和一个正整数 d。
你每次可以选择其中任意一个元素 a[i] 将其变为 a[i] + d 或 a[i] - d，这算作一
次操作。
你需要将所有的元素全部变成相等元素，如果有解，请输出最小操作次数，如果
无解请输出 -1。
输入数字 n、数字 d，和一个长度为 n 的数组 a。1 <= n <= 100000，1 <= d
<= 100, 1 <= a[i] <= 100000。
输出一个数字，表示最小的操作次数，如果无解输出 -1。



**示例 1**
**输入：**
5
2
[3,5,7,1,9]

**输出：**

6

**注意**

最优解为全部变为 5，共 1 + 0 + 1 + 2 + 2 = 6 次。

#### 解题方法：

首先判断无解的情况，可以发现 a[i]，a[i]+d, a[i]-d 在 模 d 情况下的余数不会发生
改变，因此如果原数组中的存在任意两个数字它们对 d 取余结果不同，那么此时无解。
设余数为 r。判断完无解之后，需要求出最小值。

先将数组 a[i] 排序，然后除以 d，得到从 r 变成 a[i] 需要的步数。

枚举元素 a[i]，将所有元素全部变成 a[i] 需要考虑两部分，i 之前和 i 之后 : 对于 i
之前的元素，假设都是 r，那么需要 (i-1)\*a[i]，但是因为并不都是 0，所有我们可以
用一个变量 val 存放前 i-1 项的和，然后我们在减去 val 就是前 i-1 个元素真正需要
操作的步数。
对于 i 之后的元素，也是类似的。我们假设 i 之后的所有项和为 val，假设我
们要将它们变为 r，则消耗即为 val，但是我们只需要将其变为 a[i]，因此需要减去(n-i)*a[i]。



---
算法面试：
让大家在面对面试中的算法问题时，有一个合理的思考路径；
面对算法不畏惧。
- 因为面试中的算法问题，通常并不负载，远远不需要啃完一本《算法导论》。

算法面试是什么？

让大家在面对面试中的算法问题时，有一个合理的思考路径

- 不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要，也是正确完成算法面试问题的前提

- 算法面试优秀不意味着技术面试优秀
- 技术面试优秀不意味着能够拿到offer


### 什么是给出一个合理的思考路径

算法面试的目的并不是像面试官展示一个“正确”的答案，而是给面试官展示你思考的方式。
对于我们走上职场的人来说：“正确”并不是一个绝对的答案，而是一个相对的答案。相信每一个人在实际场景中都遇到过实际的问题，如何在沟通过程中展示你在解决问题的思路模型。相信面试官会对你更感兴趣。

例如：如何对一组数据进行排序？

假设面试官问了这个问题，我们应该如何进行回答呢？
很多同学会回答：我会用快速排序来解决问题。它的算法复杂度：O(nlogn)。其实这样回答并没有错，而是一个相对“正确”的回答。
但是你却忽视了很多算法在具体使用环境中的应用。这个时候就不是选一个相对“正确”的答案，而是你在实际场景中是如何做选择的。通过跟面试官沟通这组数据在具体环境中一些特征。
比如：
- 1.这组数据有什么样的特征？
  a.有没有可能包含大量重复的数据？如果有这种可能的话，三路快排是更好的选择。
  b.是否大部分的数据距离它正确的位置很近？是否近乎有序？
例如：银行要对业务发生的时间进行排序，因为大多数的业务是先发生也是先完成，只有少部分业务可能比较复杂耗时长，虽然先发生但是后完成。这样的业务数据就非常符合近乎有序，所以对于这样的数据，我们采用插入排序更加好。
  c.是否数据的取值范围有限？比如对学生的成绩进行排序。对于这样的情况，计数排序是更好的选择。

- 2.对排序有什么额外的要求？
  a.是否需要稳定的排序？如果是的话，归并排序是一个更好的选择。

- 3.数据的存储状况是怎样的？
  a.是否是链表存储的？如果是的话，归并排序是一个更好的选择。
  b.数据的大小是否可以装载在内存里？数据量很大或者内存很小，不足以装载在内存里，需要使用外排序算法。

当你在思考这么多东西的时候，就会发现很多时候，快速排序并不是最适用的。当你在和面试官交流这些的时候，更能体现你的计算机素养更高，知识面更广，思考的维度更深。因此很多时候我们不能仅仅局限在既定给出的面试题中，去给一个“正确”的答案。而是要去思考有没有更好的答案或者有没有一些特殊的情况使得我们的答案不再正确。因此我们要不断的与面试官进行交谈。

### 什么是“正确”回答一个算法问题

- 正确还包含对问题独到的见解；
- 对算法的优化或者语言的优化；
- 代码规范；
- 容错性；

如果是一个非常难的问题的话，那么对于你的竞争对手来说也是非常难的。这时候关键就变成了你给出解决问题的思路。甚至可以通过表达解题的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅和进一步学习来解决问题。


### 算法面试优秀并不意味着你的技术面试优秀

- 算法面试只是技术面试的一部分
- 根据你的简历和应聘的职位不同，势必要考察你的其他技术方面。
- 项目经历和项目中遇到的实际问题。自己要做好项目难点的梳理
- 你遇到的印象最深的Bug是什么？这个问题很能考察你的技术深度，因此大家要好好回答。
- 面向对象
- 设计模式
- 系统设计；scalability
- 另外：网络相关，内存相关，安全相关，并发相关等等

大家要在自己面试的岗位中做好充分的准备

### 技术面试优秀也并不意味着你能拿到offer

技术面试只是面试的一部分，面试不仅仅考察你的技术水平，还要了解你过去以及形成思考行为的方式。
关于过去：参与的项目至关重要。

对于项目，我相信对于已经工作的人士来说很简单。
那么对于一些没有做过项目的新人或者没毕业的人来说，如何参与项目？
- 实习
- 参与实战项目课程学习（各大it教学网）
- 自己创建项目，做一些自己的小应用：计划表，备忘录，播放器...
- 自己解决问题：爬虫，数据分析，词频统计...
- "不是项目"的项目：一本优秀书籍代码的整理。
- 分享：自己的技术博客，github等等。

#### 通过过去了解你的思考行为方式
- 遇到的最大的挑战？
- 犯过的错误？
- 遭遇的失败？
- 最享受的工作内容？
- 遇到冲突的处理方式？
- 做的最与众不同的事？
最好是用具体的事情举例，而不是进行泛泛的回答。
比如：我遇到的最大的问题就是在学习算法的时候，非常的难。那么这就不是一个合格的回答。
应该具体回答：我在xx项目中遇到了一个算法问题，这个算法问题是我遇到最麻烦的，这个算法具体是这样的：xxx,然后我又是怎么解决的。通过解决这个算法问题我获得了xxx的样子的收获。那么这样的回答更能获得面试官的青睐。

#### 准备好面试题问面试官

- 如果我要入职，那么整个小组的运行模式是怎样的？
- 整个项目的中长期规划，后续规划是如何的？
- 这个产品中的某个问题是如何解决的？
- 为什么会选择某些技术？标准是怎样的？
- 我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入了解这种技术？


## 算法面试的准备范围

这里只讨论算法面试的范围。

### 算法面试并没有那么难

远远不需要啃完《算法导论》
![算法理论知识](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202550.png)

- 强调理论证明
- 高级数据结构与算法面试提及率很低
比如：红黑树，计算几何，B-Tree，数论，斐波那契堆，FFT等。
- 远远不需要达到信息学竞赛水平。比如：ACM
- 不要轻视基础的算法和数据结构，而去关注一些“有意思”的题目
  a.各种基本排序算法
  b.基础数据结构和算法的实现：堆，二叉树，图...
  c.基础数据结构的使用：链表，栈，队列，哈希表，图，Trie，并查集...
  d.基础算法：深度优先，广度优先，二分查找，递归...
  e.基本算法思想：递归，分治，回溯搜索，贪心，动态规划...

这些内容非常基础，并没有涵盖很高的难度。

![算法1.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202602.png)

![算法2.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202625.png)

![算法3.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202625.png)

![算法4.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202625.png)



### 选择合适的OJ

OJ(Online Judge)在线判题系统，目前网上有非常多的判题系统，可以很方便大家的做题。

建议大家不要过于偏向程序竞赛的OJ
例如：![不推荐OJ](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202707.png)

推荐：LeetCode
![推荐OJ](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202734.png)

![推荐OJ2](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202726.png)


后面我们介绍的算法题都将从这些平台中选题进行练习学习。


## 解决算法问题的整体思路

### 注意题目中的条件

- 给定一个有序数组... （这时候思考是不是可以使用二分查找）
- 有一些题目中的条件是暗示
  a.设计一个O(nlogn)的算法（那么这个算法八成离不开分治法）
  b.无需考虑额外的空间（那么我们就要思考是不是这个算法需不需要额外的空间，以空间换时间的优化）
  c.数据规模大概10000（那么O(nlogn)，O(n^2)级别的算法即可解决万级别的数据规模）

### 当没有思路的时候

- 1.自己给自己几个简单的测试用例，试验一下。
- 2.不要忽视暴力解题，暴力解题通常是思考的起点。

### 不要忽视暴力法

例题：LeetCode中第三题
1.在一个字符串中寻找没有重复字母的最长字符串？
如："abcabcbb",则结果为abc
如："bbbbb",则结果为b

如果看到这题的时候，短时间没有优解的话，可以采用暴力法。
简单思路：遍历所有的字符串来找
- 对于字符串s的子串s[i...j]
- 使用O(n^2)的算法遍历i,j,可以得到所有子串s[i...j]
- 使用O(leng(s[i...j]))的算法判断s[i...j]中是否包含重复字符串

时间的复杂度O(n^3),对于n=100的数据，可行。


### 优化算法

- 脑海中遍历一遍所有常见的算法思路
- 脑海中遍历一遍所有常见的数据结构
- 空间和时间交换（哈希表）
- 预处理信息（排序）
- 在瓶颈处找答案:O(nlogn)+O(n^2);O(n^3)  对于O(n^2)，O(n^3)部分如何优化


### 实际编写问题

- 极端条件的判断（数组为空，字符串为空，数量为0，指针为null）
- 变量名
- 模块化，复用性

### 对于基本问题，白板编程

对于基础的算法排序，大家在面试前花些时间，也是能够在面试的时候直接写出来的。基础的算法题对大家也是有帮助的。

------------

## 面试中的时间复杂度分析

在面试的过程中通常会对算法的时间复杂度有要求，甚至可能要求按时间复杂的大小来写一个算法。因此我们对于了解时间复杂度是很有要求的。可以参考我之前写的文章：

### 到底什么是大O

- n表示数据规模
- O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。

![大O.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202742.png)

![不同的时间复杂度.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202746.png)

冷知识：
在学术界，严格的讲，O(f(n))表示算法执行的上届 归并排序算法的时间复杂度是O(nlogn),同时也是O(n^2)

在业界，我们就使用O来表示算法执行的最低上界 我们一般不会说归并排序是O(n^2)的

算法规模一样的情况，存在相等

![时间复杂度相等.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202752.png)

如果规模不一样的话，是不能等同
![算法不等同.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202759.png)



### 练习

有一个字符串数组，将数组中的每一个字符串按照字母序排序；之后再将整个字符串数组按照字典序排序。整个操作的时间复杂度？

解：
1.假设最长的字符串长度为s;数组中有n个字符串
2.对每个字符串排序：O(slog(s))
3.将数组中的每个字符串按字母序排序：O(n*slog(s))
4.将整个字符串数组按照字典序排序：O(s*nlog(n))
那么整个操作的时间复杂度就是:
```
O(n*slog(s))+O(s*nlog(n)) = O(n*slogs+s*nlogn) = O(n*s(logs+logn))
```

### 算法在有些情况下是跟用例有关的

![算法与用例相关.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027202805.png)



### 数据规模的概念

提问：对10^5的数据进行选择排序？结果计算机假死？

我们来看一组简单的**加法测试**数据

![测试数据](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027204827.png)



我们可以得到这样的一个结论：

- 如果我们想要在1s之内解决问题：

   O(n^2)的算法可以处理大约10^4级别的数据；

   O(n)的算法可以处理大约10^8级别的数据；

   O(nlogn)的算法可以处理大约10^7级别的数据

再回到上面的提问：如果我们要用选择排序去处理10^5的数据，选择排序的时间复杂度是O(n^2)，那么就需要处理10^10的数据。可以对比我们测试简单的**加法测试**数据，都需要很长的时间，那么我们再用选择排序处理更为复杂的数据，将会耗时更长！就很可能会造成计算机假死。

因此我们在面试的时候要注意面试官给我们的数据规模到底有多大。针对不同的数据规模，我们都要有相应的算法选择。



### 空间复杂度

- 多开一个辅助的数据：O(n)

- 多开一个辅助的二维数据：O(n^2)

- 多开常数空间：O(1)

- 递归调用是有空间代价的,递归的深度是多少，那么他的空间复杂度就是多少。

例如：

![image-20201027205931102](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027205936.png)





## 常见的复杂度分析



## O(1)

典型的常数级别的算法

![image-20201027210120994](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027210122.png)

### O(n)

从0到n级别的时间复杂度，典型特性：一个循环，并且这个循环与n有关

![image-20201027210159691](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027210200.png)

另外对于1/2*n次的操作，空间复杂度也是O(n)

![image-20201027210424769](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027210725.png)

### O(n^2)

对于双重循环来说，基本可以判定为O(n^2)的时间复杂度

举例：选择排序

![image-20201027210717273](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027210718.png)

提问：那么只要看到双重for循环的代码，就认为是O(n^2)的时间复杂度吗？

答案是否定的。那么对下面一个函数举例来说，第二层循环是一个常数，那么它的时间复杂度就是O(n)

![image-20201027210951248](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027212225.png)





### O(logn)级别算法

下面一个例子是二分查找算法

![image-20201027211145765](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027212221.png)

来分析一下二分查找法的时间复杂度O(logn)

![image-20201027212214753](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027212215.png)

可以看出是一个对数级的函数。

再看一个函数的时间复杂度，整形转成字符串,这个函数是有一点点小漏洞的。

![image-20201027212512295](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027212513.png)

那么以2为底与以10为底的对数时间复杂度没有区别吗？

我们来回顾一下高中所学的对数。

![image-20201027212822349](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027213248.png)



可以看出只相差一个常数，因此我们可以将这个常数省略。





### O(sqrt(n))

一个简单的根号n级别的时间复杂度

![image-20201027213241057](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201027213242.png)

这个函数还有优化的余地，有兴趣的同学可以自己研究一下。



## 复杂度实验

我们以为自己写出了一个O(nlogn)算法，结果实际却是O(n^2)算法？

那么有什么方法可以快速看出我们写的算法时间复杂度到底是多少呢？
我们回顾上面的数据规模，大家熟记到心里，最好是等减一个数量级。
我们来通过实验来观察数据规模。

### 递归算法复杂度分析

不是有递归的函数就一定是O(nlogn)!

![递归算法.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201028191548.png)



- 如果递归函数中，只进行一次递归调用
- 递归深度为depth
- 在每个递归函数中，时间复杂度为T
- 则总体的时间复杂度为O(T*depth)

![递归算法例题.png](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201028191542.png)

对递归算法复杂度有兴趣的同学可以查阅：**主定理**。涵盖了所有递归可能的时间复杂度



### 均摊复杂度分析（Amoritized Time）

之前所介绍的算法时间度是一个算法从头到尾运行的时间复杂度是怎样的。但是在有些情况下，一些算法的复杂度相对比较高是为了方便其他的操作，所以很多时候，我们需要将这个算法的复杂度和其他算法的复杂度一起来计算。那么在这个情况下，复杂度比较高的算法会均摊到其他算法复杂度上，因此叫做**均摊复杂度分析**。

两个条件满足时使用：

　　1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；

　　2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。　

一般均摊时间复杂度就等于最好情况时间复杂度。



我们最典型的例子是：动态数组（Vector）动态数组相对于静态数组可以自动扩容，自动缩容。也可以自己写一个动态的栈，动态的队列。

参考文章：[[浅析最好、最坏、平均、均摊时间复杂度](https://www.cnblogs.com/virgosnail/p/9829663.html)](https://www.cnblogs.com/virgosnail/p/9829663.html)



## 真实面试题



### 数组中的常见问题

排序：选择排序；插入排序；归并排序；快速排序

查找：二分查找法

数据结构：栈；队列；堆

....



### 如何写出正确的程序

相信大家在自己写一个快速排序或者调试堆等一个算法的时候，明明只需要在数组中完成程序，可是我们需要将不同的索引去指向不同的数组元素。可是这些索引,代码好像总是不听话，不能指向正确的数组元素。那么接下来我们将介绍如何去写出一个正确的程序，及时大家不能写出正确的程序，也能掌握基本的框架。



### 举例：二分查找法

二分查找法的思想在1946年提出。第一个没有bug的二分查找法在1962年才出现。这也就是为什么往往写出一个没有bug的程序是很难的。但是我们只是去思考一个算法的思想，确是很简单的。这也就是大公司为什么不要你用自然的语言去描述算法思想，而是要落实到代码上，去真正实现这个代码。

![image-20201028201423774](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201028201425.png)

二分查找法思路：

对于一个有序的数列，我们先查找中间的数，如果是的话就查找到了。如果不是的话，就以中间的元素为中心，左边的元素都小于这个元素，右边的元素都大于这个元素。如果我们待查找的数小于这个元素，那么我们就在左边进行查找。反之右边查找。这个思路非常的简单，但是我们很多同学在代码层面实现的时候就会遇到各种各样的问题。那么这些问题都集中在边界的处理上



- 想清楚数组的范围区间，并初始化 int l = 0, r = n - 1;在[l...r]的范围里寻找target, l表示左，r表示右
- 循环中如何确定l和r是小于等于还是小于？基于第一点，因此是小于等于
- 当目标值target不在中点且大于中点值时，需要更新左边界。这时候再基于第一点,是闭区间内查找目标值。确认左边界l=mid+1
- 以此类推得出右边界 r = mid - 1;

核心：清晰的定义了：int l = 0, r = n - 1; // 在[l...r]的范围里寻找target，当确定了它们的意义后，我们在后续的循环中就要维护它的意义。必须在[l...r]的范围里寻找target。专业术语：**循环不变量**，怎么理解循环不变量，在我们的代码中，l与r的值虽然是不停的变化的，但是它们的声明确实不变的。我们待寻找的target在[l...r]的范围在确定边界左为闭区间，右为闭区间的范围里。只要维护住我们的算法的**循环不变量**，也就能保证我们的算法是正确的。有兴趣的同学可以在网上搜索一下**循环不变量**。

建议同学们回顾：快速排序，归并排序，堆实现，图论中的最小生成树等。相信大家理解了这个思想，能够更好的帮助大家算法的学习。

以下是Java实现

```java
public class BinarySearch {

    private BinarySearch(){}

    public static int binarySearch(Comparable[] arr, int n, Comparable target){

        int l = 0, r = n - 1; // 在[l...r]的范围里寻找target
        while(l <= r){    // 当 l == r时,区间[l...r]依然是有效的
            int mid = (l+r)/2;
            //int mid = l + (r - l) / 2;
            if(arr[mid].compareTo(target) == 0) return mid;
            if(target.compareTo(arr[mid]) > 0)
                l = mid + 1;  // target在[mid+1...r]中; [l...mid]一定没有target
            else    // target < arr[mid]
                r = mid - 1;  // target在[l...mid-1]中; [mid...r]一定没有target
        }

        return -1;
    }

    public static void main(String[] args) {

        int n = (int)Math.pow(10, 7);
        Integer data[] = Util.generateOrderedArray(n);

        long startTime = System.currentTimeMillis();
        for(int i = 0 ; i < n ; i ++)
            if(i != binarySearch(data, n, i))
                throw new IllegalStateException("find i failed!");
        long endTime = System.currentTimeMillis();

        System.out.println("Binary Search test complete.");
        System.out.println("Time cost: " + (endTime - startTime) + " ms");
    }
}
```



```java
/**
 * 生成随机数组
 */
public class Util {

    private Util(){}

    public static Integer[] generateRandomArray(int n, int rangeL, int rangeR) {

        assert n > 0 && rangeL <= rangeR;

        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++)
            arr[i] = (int)(Math.random() * (rangeR - rangeL + 1)) + rangeL;
        return arr;
    }

    public static Integer[] generateOrderedArray(int n) {

        assert n > 0;

        Integer[] arr = new Integer[n];

        for (int i = 0; i < n; i++)
            arr[i] = i;
        return arr;
    }
}
```

接下来我们看一下，如果我们修改了边界定义 r=n，那么又会发生哪些变化呢？
```java
  public static int binarySearch(Comparable[] arr, int n, Comparable target){

        int l = 0, r = n; // 在[l...r)的范围里寻找target
        while(l < r){    // 当 l == r 时, 区间[l...r)是一个无效区间
            int mid = (l+r)/2;
           // int mid = l + (r - l) / 2;
            if(arr[mid].compareTo(target) == 0) return mid;
            if(target.compareTo(arr[mid]) > 0)
                l = mid + 1;  // target在[mid+1...r)中; [l...mid]一定没有target
            else    // target < arr[mid]
                r = mid;  // target在[l...mid)中; [mid...r)一定没有target
        }

        return -1;
    }
```

我们会发现小的边界地方也会相应的改变，因此我们要注意保证定义不发生改变。简单的十行代码却会随着定义发生诸多的变化，因此我们要很好的去理解算法，如果只考去背的话，很容易出现错误，而且记忆力太大了。背诵是没有意义的！我们的程序是理解写出来的，不是背出来的。我们修改了那么多代码，只是因为边界发生了改变。因此我们需要保证理解**循环不变量**即可。

当我们写完二分查找算法后，大家仔细观察有没有问题呢？

其实是有一个小小隐藏的bug，也是1962年才意识到这个bug，这个bug就发生在 (l+r)/2，我们定义的两个Int类型相加，如果足够大会发生整型溢出的情况。因此，如果我们为了防止整型溢出的话，要避免使用加法，改用减法。当然了，我已经将代码写在了上面。

对于一些面试题的时候，我们也要注意这些小细节，以免面试官正好要考察的就是整型溢出的问题！



### 总结

如何写出正确的程序？

- 明确变量的含义

每个变量都要保证自身的定义，而不是我们随便写出来的

- 循环不变量

在确定定义后，我们在循环中不断的改变变量的取值，但是不能改变变量的含义，我们要维护在循环中的变量含义

- 小数据量调试

当发生错误的时候，不要慌张，我们可以设置几个非常小的数据量集进行测试，但是要注意考虑数据集的边界问题

- 大数据量测试

在保证小数据量调试没问题后，我们也要进行大数量的测试，保证程序的正确与性能





## 面试实战

`LeetCode`上283号问题：**Move Zeros**

题目地址：https://leetcode.com/problems/move-zeroes/

![image-20201105213301795](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201105213310.png)

在我们写代码之前，我们来看下`LeetCode`都有哪些规则？

![image-20201105213850713](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201105213852.png)

观察之后，可以发现：我们只需要在函数内编写算法的代码逻辑即可。当然我们在自己本地写的时候也可以编写辅助函数，写测试。上传的时候，只需要将主要代码上传即可。



### 解题思路

最简单的方式

第一步：我们将所有非零的数取出来。

![image-20201108113517335](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108113525.png)



第二步：然后将所有非零的元素填补到原先的数组中

![image-20201108113614996](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108113616.png)

第三步：将后面没有填补的位置，赋值为零。

![image-20201108113740708](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108113741.png)



我们接下来写我们的代码：

```java
// 时间复杂度: O(n)
// 空间复杂度: O(n)
class Solution {
    public void moveZeroes(int[] nums) {

        ArrayList<Integer> nonZeroElements = new ArrayList<Integer>();

        // 将vec中所有非0元素放入nonZeroElements中
        for(int i = 0 ; i < nums.length ; i ++)
            if(nums[i] != 0)
                nonZeroElements.add(nums[i]);

        // 将nonZeroElements中的所有元素依次放入到nums开始的位置
        for(int i = 0 ; i < nonZeroElements.size() ; i ++)
            nums[i] = nonZeroElements.get(i);

        // 将nums剩余的位置放置为0
        for(int i = nonZeroElements.size() ; i < nums.length ; i ++)
            nums[i] = 0;
    }

    public static void main(String args[]){

        int[] arr = {0, 1, 0, 3, 12};

        (new Solution()).moveZeroes(arr);

        for(int i = 0 ; i < arr.length ; i ++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```



### 如何优化算法

在我们上面的算法中，我们使用了辅助的额外空间（定义了一个数组）。那么我们有没有办法不使用额外的空间？



我们再设置一个索引K。

K-[0...K)中保存所有当前遍历过的非0元素。

下列动图 蓝色表示定义的K索引，红色表示数组索引。

![动画演示](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108133407.gif)

通过动画演示，我们可以看出大概思路。当所有元素遍历完后，将K后的所有元素都赋值为0即可结束。

接下来我们来编写代码：

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution2 {
    public void moveZeroes(int[] nums) {

        int k = 0; // nums中, [0...k)的元素均为非0元素

        // 遍历到第i个元素后,保证[0...i]中所有非0元素
        // 都按照顺序排列在[0...k)中
        for(int i = 0 ; i < nums.length ; i ++)
            if( nums[i] != 0 )
                nums[k++] = nums[i];

        // 将nums剩余的位置放置为0
        for(int i = k ; i < nums.length ; i ++)
            nums[i] = 0;
    }

    public static void main(String args[]){

        int[] arr = {0, 1, 0, 3, 12};

        (new Solution2()).moveZeroes(arr);

        for(int i = 0 ; i < arr.length ; i ++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```



#### 进一步优化

当我们使用上一种方法的时候，会发现在最后赋值的时候全部循环一遍设置为零，那么我们有没有办法进一步优化呢？

接下来我们再来看看我们如何进一步优化？

当我们发现非零元素后，我们可以与之前的零元素进行位置交换！我们来看动画！

![优化算法2](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108141059.gif)

我们来编写代码！

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution3 {
    public void moveZeroes(int[] nums) {

        int k = 0; // nums中, [0...k)的元素均为非0元素

        // 遍历到第i个元素后,保证[0...i]中所有非0元素
        // 都按照顺序排列在[0...k)中
        // 同时, [k...i] 为 0
        for(int i = 0 ; i < nums.length ; i ++)
            if(nums[i] != 0)
                swap(nums, k++, i);
    }

    private void swap(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    public static void main(String args[]){

        int[] arr = {0, 1, 0, 3, 12};

        (new Solution3()).moveZeroes(arr);

        for(int i = 0 ; i < arr.length ; i ++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```



对于这样的代码，我们还有没有进一步优化的空间呢？



#### 再进一步优化

当我们如果在特殊情况下，所有元素都是非空元素，那么我们的数组就会自己跟自己交换一遍。因此我们需要判断一下**k索引**下的元素与**i索引**下的元素是否相等。

接下来我们进一步优化代码：

```java
// 原地(in place)解决该问题
// 时间复杂度: O(n)
// 空间复杂度: O(1)
class Solution4 {

    public void moveZeroes(int[] nums) {

        int k = 0; // nums中, [0...k)的元素均为非0元素

        // 遍历到第i个元素后,保证[0...i]中所有非0元素
        // 都按照顺序排列在[0...k)中
        // 同时, [k...i] 为 0
        for(int i = 0 ; i < nums.length ; i ++)
            if(nums[i] != 0)
                if(k != i)
                    swap(nums, k++, i);
                else
                    k ++;
    }

    private void swap(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    public static void main(String args[]){

        int[] arr = {0, 1, 0, 3, 12};

        (new Solution4()).moveZeroes(arr);

        for(int i = 0 ; i < arr.length ; i ++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }
}
```



我们可以看出，一个很简单的算法问题，都有诸多可以优化的地方。因此我们在写算法的时候，要多多思考自己写的算法是不是有改进的地方。在面试的时候也可以将你的优化算法的细节展示给面试官。



### 练习



通过上述的解题思路，大家可以试着自己做几道练习题

#### 练习题一

在`LeetCode`中的第27道练习题:https://leetcode-cn.com/problems/remove-element/

![image-20201108163111932](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108163113.png)

![image-20201108163130300](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108163131.png)



#### 练习题二

题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

![image-20201108163401858](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108163403.png)



#### 练习题三

题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/



![image-20201108163632397](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108163633.png)

![image-20201108163649884](https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/interview/java20201108163651.png)



这里作为大家练习题，这里就不放答案了。可以自己到`LeetCode`上做。



### 基础算法思路应用











